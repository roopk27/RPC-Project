/*
 * server.c - server-side implementation for remote system monitoring.
 */

#include <rpc/rpc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <utmpx.h>

#include "date.h" /* generated by rpcgen from date.x */

#define TIME_STR_LEN 128
#define USERS_STR_LEN 512

static void format_time_string(int option, char out[TIME_STR_LEN])
{
    time_t now = time(NULL);
    struct tm tm_now;

    out[0] = '\0';
    if (localtime_r(&now, &tm_now) == NULL) {
        snprintf(out, TIME_STR_LEN, "(time unavailable)");
        return;
    }

    switch (option) {
    case 1:
        strftime(out, TIME_STR_LEN, "%A, %B %d, %Y", &tm_now);
        break;
    case 2:
        strftime(out, TIME_STR_LEN, "%T", &tm_now);
        break;
    case 3:
    case 8:
        strftime(out, TIME_STR_LEN, "%A, %B %d, %Y - %T", &tm_now);
        break;
    default:
        /* Leave empty if not requested */
        out[0] = '\0';
        break;
    }
}

static int read_cpu_times(unsigned long long *idle_all, unsigned long long *total)
{
    FILE *fp = fopen("/proc/stat", "r");
    if (!fp) {
        return -1;
    }

 
    char line[512];
    if (!fgets(line, sizeof(line), fp)) {
        fclose(fp);
        return -1;
    }
    fclose(fp);

    unsigned long long user = 0, nice = 0, system = 0, idle = 0, iowait = 0;
    unsigned long long irq = 0, softirq = 0, steal = 0, guest = 0, guest_nice = 0;

    int n = sscanf(line, "cpu  %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
                   &user, &nice, &system, &idle, &iowait, &irq, &softirq,
                   &steal, &guest, &guest_nice);
    if (n < 4) {
        return -1;
    }

    unsigned long long idle_sum = idle + iowait;
    unsigned long long total_sum = user + nice + system + idle + iowait + irq + softirq + steal;

    *idle_all = idle_sum;
    *total = total_sum;
    return 0;
}

static double cpu_usage_percent(void)
{
    unsigned long long idle1 = 0, total1 = 0;
    unsigned long long idle2 = 0, total2 = 0;

    if (read_cpu_times(&idle1, &total1) != 0) {
        return -1.0;
    }

    /* Short sampling window to compute utilization */
    usleep(200000); /* 200 ms */

    if (read_cpu_times(&idle2, &total2) != 0) {
        return -1.0;
    }

    unsigned long long delta_idle = (idle2 > idle1) ? (idle2 - idle1) : 0;
    unsigned long long delta_total = (total2 > total1) ? (total2 - total1) : 0;
    if (delta_total == 0) {
        return 0.0;
    }

    double usage = 100.0 * (1.0 - ((double)delta_idle / (double)delta_total));
    if (usage < 0.0) usage = 0.0;
    if (usage > 100.0) usage = 100.0;
    return usage;
}

static double mem_usage_percent(void)
{
    FILE *fp = fopen("/proc/meminfo", "r");
    if (!fp) {
        return -1.0;
    }

    unsigned long long mem_total_kb = 0;
    unsigned long long mem_avail_kb = 0;

    char key[64];
    unsigned long long value = 0;
    char unit[32];

    while (fscanf(fp, "%63s %llu %31s\n", key, &value, unit) == 3) {
        if (strcmp(key, "MemTotal:") == 0) {
            mem_total_kb = value;
        } else if (strcmp(key, "MemAvailable:") == 0) {
            mem_avail_kb = value;
        }
        if (mem_total_kb && mem_avail_kb) {
            break;
        }
    }

    fclose(fp);

    if (mem_total_kb == 0) {
        return -1.0;
    }

    unsigned long long used_kb = (mem_avail_kb <= mem_total_kb) ? (mem_total_kb - mem_avail_kb) : 0;
    return 100.0 * ((double)used_kb / (double)mem_total_kb);
}

static void load_and_procs(double *load1, int *procs_running, int *procs_total)
{
    *load1 = -1.0;
    *procs_running = -1;
    *procs_total = -1;

    FILE *fp = fopen("/proc/loadavg", "r");
    if (!fp) {
        return;
    }

    /* Format: 1min 5min 15min running/total lastpid */
    double l1 = 0.0, l5 = 0.0, l15 = 0.0;
    int run = 0, total = 0;
    if (fscanf(fp, "%lf %lf %lf %d/%d", &l1, &l5, &l15, &run, &total) == 5) {
        *load1 = l1;
        *procs_running = run;
        *procs_total = total;
    }

    fclose(fp);
}

static void logged_in_users(int *count_out, char out[USERS_STR_LEN])
{
    out[0] = '\0';
    *count_out = 0;

    /* Track unique usernames */
    const int MAX_UNIQUE = 64;
    /* Use a conservative fixed max for usernames. */
    enum { USERNAME_MAX = 64 };
    char seen[MAX_UNIQUE][USERNAME_MAX];
    int seen_count = 0;

    setutxent();
    struct utmpx *ut;
    while ((ut = getutxent()) != NULL) {
        if (ut->ut_type != USER_PROCESS) {
            continue;
        }

        /* ut_user is not necessarily NUL-terminated */
        char user[USERNAME_MAX];
        const size_t ulen = sizeof(ut->ut_user);
        const size_t copy_len = (ulen < (USERNAME_MAX - 1)) ? ulen : (USERNAME_MAX - 1);
        memcpy(user, ut->ut_user, copy_len);
        user[copy_len] = '\0';

        /* Trim trailing spaces */
        for (int i = (int)strlen(user) - 1; i >= 0; --i) {
            if (user[i] == ' ' || user[i] == '\t' || user[i] == '\n' || user[i] == '\r') {
                user[i] = '\0';
            } else {
                break;
            }
        }

        if (user[0] == '\0') {
            continue;
        }

        /* Check uniqueness */
        int already = 0;
        for (int i = 0; i < seen_count; i++) {
            if (strncmp(seen[i], user, USERNAME_MAX) == 0) {
                already = 1;
                break;
            }
        }
        if (!already && seen_count < MAX_UNIQUE) {
            strncpy(seen[seen_count], user, USERNAME_MAX);
            seen[seen_count][USERNAME_MAX - 1] = '\0';
            seen_count++;

            if (out[0] != '\0') {
                strncat(out, ", ", USERS_STR_LEN - strlen(out) - 1);
            }
            strncat(out, user, USERS_STR_LEN - strlen(out) - 1);
        }

        (*count_out)++; /* count sessions */
    }
    endutxent();

    if (out[0] == '\0') {
        snprintf(out, USERS_STR_LEN, "(none)");
    }
}

/*
 * RPC procedure implementation.
 */

rpcstat_stats *
rpcstat_1_svc(rpcstat_request *req, struct svc_req *rqstp)
{
    (void)rqstp; /* unused */
    static rpcstat_stats result;
    static char timebuf[TIME_STR_LEN];
    static char usersbuf[USERS_STR_LEN];

    /* Clear scalar fields; keep pointers stable */
    memset(&result, 0, sizeof(result));
    result.timestr = timebuf;
    result.users = usersbuf;

    /* Default sentinels for "not requested" */
    result.cpu_percent = -1.0;
    result.mem_percent = -1.0;
    result.load1 = -1.0;
    result.procs_running = -1;
    result.procs_total = -1;
    result.user_count = -1;

    const int opt = req ? req->option : 8;

    if (opt == 1 || opt == 2 || opt == 3 || opt == 8) {
        format_time_string(opt, timebuf);
    } else {
        timebuf[0] = '\0';
    }

    if (opt == 4 || opt == 8) {
        result.cpu_percent = cpu_usage_percent();
    }

    if (opt == 5 || opt == 8) {
        result.mem_percent = mem_usage_percent();
    }

    if (opt == 6 || opt == 8) {
        load_and_procs(&result.load1, &result.procs_running, &result.procs_total);
    }

    if (opt == 7 || opt == 8) {
        logged_in_users(&result.user_count, usersbuf);
    } else {
        usersbuf[0] = '\0';
    }

    return &result;
}
